# nRF52

<details>
  <summary>Addon NRF52840</summary>
  
![](pics/nrf52833_31.png)

![](pics/nrf52833_33.png)

</details>
<details>
  <summary>Addon NRF52833</summary>
  
![](pics/nrf52833_35.png)

![](pics/nrf52833_34.png)

</details>

## Bypass APPROTECT
Вся серия МК nRF52 имеет один вариант защиты. Защита от чтения прошивки - **APPROTECT**. При включении защиты отключается доступ к МК по SWD. Защита включается, когда в регистр APPROTECT записано 0x00.

![500](pics/nrf52833_14.png)
###### Note
Стоит отметить, что регистр находится в в энергонезависимой памяти (non-volatile memory - NVM). При этом сама перезапись регистра ничем не ограничена, в случае если есть доступ через SWD.

Более подробно можно прочитать в оригинальном [исследовании](https://limitedresults.com/2020/06/nrf52-debug-resurrection-approtect-bypass/).

###### Note
Для тестирования можно запаять чип nRF52 на аддон без блокировки и выставить на нем защиту. Для этого нужно подать на МК питание. Затем переключить SWD выводы на внешний разъем. По умолчанию они заведены в Pi Pico на Chip'olino. После этого можно подключить J-Link к уже включенному МК и установить защиту с помощью утилиты **nrfjprog**.

```bash
# Включить питание nRF52 (3.3V)
py.exe chipctrl.py -p COM5 -gp 4 1

# Переключить SWD пины от МК на разъем для внешнего подключения
py.exe chipctrl.py -p COM5 -swd ext

# Установить защиту на nRF52
nrfjprog --rbp ALL -f NRF52
```
![500](pics/nrf52833_13.png)


### Glitch MCU
Целью атаки является момент аппаратной инициализации МК. При подаче питания МК проверяет значение в регистре APPROTECT и в зависимости от него может отключить доступ через SWD.
###### Attention!
Важно понимать, что данная уязвимость была поправлена производителем чипов. В ранних ревизиях чипов защита была выключена по умолчанию. Во время аппаратной инициализации (до исполнения кода) защита включалась, если в APPROTECT было соответствующее значение. В новых ревизиях защита включена по умолчанию.

![500](pics/nrf52833_15.png)

###### Note
Ревизию МК (HW revision) можно понять по маркировке на корпусе.

![300](pics/nrf52833_16.png)

#### Запуск атаки на NRF52
```bash
py.exe chipctrl.py -p COM5 -g -t nrf52_mosfet -o 198000 475000 -w 3 30
```
Значение смещения и ширины импульса сильно отличаются, как от модели (например nRF52840 или nRF52833), так и от ревизии МК. На скриншоте ниже показан участок на линии питания DEC1, куда нужно целиться. Также форма сигнала на DEC1 может сильно отличаться от картинки - ревизии МК сильно влияют. Но найти данный участок возможно всегда. Он всегда имеет длительность около 15 мкс и ему предшествует характерный провал. От провала до конца участка всегда чуть менее 20 мкс.

![](pics/nrf52833_32.png)
![](pics/nrf52833_17.png)
![](pics/nrf52833_21.png)
![](pics/nrf52833_22.png)

Во время успешного перебора в поле **Log** должно мелькать значение **"23000000"**. Такое значение вычитывается, когда происходит попытка чтения **AHB-AP  Identification Register** на заблокированном МК. Для разблокированного МК вычитается значение **0x24770011** (только для nRF52).

![](pics/nrf52833_9.png)

Успех атаки определяется по вычитанному значению **AHB-AP ID**. 

###### Note
Высокая скорость перебора в атаке на nRF52 достигается за счет того, что SWD реализован непосредственно на RP2040 с помощью PIO. Это гораздо быстрее, чем использовать внешний программатор (как J-link) для вычитывания ID между гличами.


### Dump firmware

После успешной атаки SWD AP станет доступен. Тогда уже можно использовать J-Link непосредственно для вычитывание прошивки. Не отключая аддон от Chip'olino переключите пины SWD от nRF52 на внешний разъем и подключите к нему J-Link.
```bash
# Переключить SWD пины от МК на разъем для внешнего подключения
py.exe chipctrl.py -p COM5 -swd ext
```

![](pics/nrf52833_11.png)

![](pics/nrf52833_fw_dump.png)

После подключения J-Link из NRF можно штатно вычитывать прошивку, например, через J-Mem.

###### Note
Приятный бонус. Обычно после перезагрузки МК он снова будет заблокирован, но это случается не всегда. Бывает, что МК останется разблокированным до следующей принудительной блокировки.

### Glitch example

nRF52, как уже было сказано, довольно сильно отличаются в зависимости от HW revision и модели чипа. Поэтому ниже приведены осциллограммы для некоторых МК этой серии без глича и в момент глича.
###### nRF52840 rev A0
```bash
# Запуск
py.exe chipctrl.py -p COM5 -g -t nrf52_mosfet -o 198300 296000 -w 12 25

# Результат
Target synchronized
Glitching ---> Offset: 198695/296000, Width: 18/25, Log: b'11007724'
Glitch successed
Offset: 198695, Width: 18

#
Ширина импульса: ~300 нс
```
![](pics/nrf52833_27.png)
![](pics/nrf52833_28.png)
![](pics/nrf52833_29.png)

###### nRF52833 rev A0

```bash
# Запуск
py.exe chipctrl.py -p COM5 -g -t nrf52_mosfet -o 255000 296000 -w 16 21

# Результат
Target synchronized
Glitching ---> Offset: 255067/296000, Width: 19/21, Log: b'11007724'
Glitch successed
Offset: 255067, Width: 19

#
Ширина импульса: ~250 нс
```

![](pics/nrf52833_24.png)
![](pics/nrf52833_25.png)
![](pics/nrf52833_26.png)

### Links
* https://limitedresults.com/2020/06/nrf52-debug-resurrection-approtect-bypass/


