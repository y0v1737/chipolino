# NXP
## LPC2148

<details>
  <summary>Addon LPC2148</summary>
  
![](pics/lpc2148_10.png)

![](pics/lpc2148_23.png)

</details>

### Bypass CRP1, CRP2
LPC2148 имеет несколько степеней защиты. Текущий уровень защиты определяется значением записанным во flash память по адресу 0x1FC. В данной главе речь идет об обходе защиты уровня CRP1 и CRP2. В обоих режимах работы отключена отладка через JTAG и некоторые команды, которые может выполнять bootloader.

![400](pics/lpc2148_2_1.png)

Данный МК всегда стартует с bootloader. Код в bootloader содержит проверки значения по адресу 0x1FC и в зависимости от содержимого настраивает МК. Одна из таких проверок расположена непосредственно перед переходом МК в режим ISP. Именно эта проверка и является целью атаки. Суть в том, чтобы оказаться в режиме ISP и МК думал, что защита не установлена. 

![400](pics/lpc2148_5_1.png)

###### Note
Можно вычитать bootloader из LPC2148, провести реверс-инжиниринг и своими глазами найти эту проверку. Bootloader расположен в памяти 0x7FFFD000-0x80000000.

###### Attention!
Перед тем, как провести атаку  стоит убедиться, что установлен один из целевых уровней защиты - CRP1 или CRP2. Для этого нужно подключить аддон к Chip'olino и начать атаку. Chip'olino поднимет питание МК и попытается синхронизироваться с bootloader-ом.  
![600](pics/lpc2148_check_protect.png)

```bash
py.exe chipctrl.py -p COM6 -g -t lpc2148 -o 255800 270100 -w 275 295
```

Если в результате процесс глича начнется, то это значит, что МК в CRP1 или CRP2 режиме. Убедитесь, что появилась надпись "Target synchronized".

![](pics/lpc2148_9.png)

###### Debug note
"Target not synchronized" значит, что нет связи с МК. Проблема может быть в сборке аддона или же в том, что установлен уровень защиты CRP3.

###### Note
Для предварительной тренировки на тестовом МК можно удобно выставлять защиту через JTAG. Используйте утилиту J-Mem вместе с J-Link. Подключите аддон к Chip'olino, а J-Link к аддону, как показано ниже.

![600](pics/lpc2148_jlink.png)

Для того, что бы подать необходимое питание на МК и он был готов к подключению по JTAG можно запустить скрипт для атаки. В случае, если защита не установлена, то он просто включит МК. После этого можно подключаться через J-link стандартным образом. Запишите **0x12345678** или **0x87654321** по адресу 0x1FC - защита будет установлена.

![600](pics/lpc2148_21.png)

![400](pics/lpc2148_14.png)

#### Glitch MCU
Для данного МК момент атаки - это исполнение кода bootloader-ом, то есть момент загрузки МК до всякого взаимодействия с ним. Далее МК загружается в режиме ISP и либо отвечает на команды чтения, либо выдает ошибку (если глич был неудачный). Сама же атака проходит по каналу питания МК. Питающие МК 3.3В проходят на плате Chip'olino через мультиплексор, что позволяет притянуть линию питания к "земле" в момент атаки.
После попытки сбоя Chip'olino попытается синхронизироваться с LPC2148 и запросит несколько байт из flash памяти для того, чтобы проверить успешность атаки.

![](pics/lpc2148_22.png)

![](pics/lpc2148_15_1.png)
###### Note
Кварцевый резонатор (12МГц) необходим для работы МК, даже в режиме ISP (bootloader).

Запуск атаки для LPC2148:

```bash
py.exe chipctrl.py -p COM5 -g -t lpc2148 -o 255500 270100 -w 275 295
```
* -p - порт Chip'olino;
* -g - glitch команда;
* -t - наименование целевого МК;
* -o - offset - смещение по времени (в попугаях) от фронта сигнала Reset;
* -w - width - ширина импульса (в попугаях) управляющего N-MOSFET;

![600](pics/lpc2148_9.png)

 Надпись "LOCK" в поле **Log** значит, что атака идет корректно.
###### Note
У вас может отличаться порт, смещение и ширина.

Если вы используете Chip'olino вместе с аддоном, то можно просто запустить скрипт, как показано выше. Параметры смещения и ширины импульса сильно не изменятся. Если что-то не получилось, то ниже приведены скриншоты с осциллографа для успешной атаки. Можно сравнить и форму сигналов, и временные параметры, после чего провести дополнительную подстройку смещения и длительности.

![600](pics/lpc2148_15.png)
![600](pics/lpc2148_16.png)
![600](pics/lpc2148_17.png)
![600](pics/lpc2148_19.png)

###### Note
Внимательно ознакомьтесь со скриншотами. В случае проблем они могут сильно выручить.
###### Glitch parameters
* ~110 мкс от старта МК (HW init на скриншоте);
* ~83 мкс от начала исполнения bootloader (bootloader exec start на скриншоте);
* ~1.2 мкс длительность импульса;
* Способ: мультиплексор на линии питания (3.3V) МК.

![600](pics/lpc2148_20.png)

#### Dump firmware
После успешной атаки не отключайте аддон от Chip'olino, так он останется запитан и будет готов к общению по UART. Лучше всего подключить USB-UART адаптер до начала атаки к аддону и к ПК.
Прошивка расположена во flash памяти, ее размер зависит от МК - нужно предварительно изучить карту памяти вашего МК.

![500](pics/lpc2148_4.png)

Для LPC2148 необходимо вычитать регион 0x00000000-0x00080000. Для этого есть скрипт ***/scripts/dump_lpc2148.py***. Запустите его, как показано ниже, учтите, что порт нужно указать для USB-UART адаптера.

```bash
# Дамп региона flash памяти lpc2148 в файл flash_lpc2148.bin
py.exe .\dump_lpc2148.py -p COM8 -a 0 0x00080000 -f flash_lpc2148.bin
```
###### Note
Дамп памяти через UART не самая быстрая процедура. Можно этого избежать. Можно прочитать только 0-ой сектор через UART, потом стереть только 0-ой сектор (***/scripts/erase_lpc2148.py***). После этого защита с МК будет снята, так как значение, определяющее уровень защиты расположено по адресу 0x1FC (0-ой сектор). Оставшуюся часть прошивки можно будет вычитать через JTAG.

![500](pics/lpc2148_1.png)


```bash
# Дамп 0-ого сектора памяти lpc2148 в файл zero_sector.bin
py.exe .\dump_lpc2148.py -p COM8 -a 0 0x1000 -f zero_sector.bin

# Когда 0-ой сектор прочтен, его можно стереть.
py .\erase_lpc2148.py -p COM8
```

![500](pics/lpc2148_12.png)

![500](pics/lpc2148_13.png)

![600](pics/lpc2148_jlink.png)
![500](pics/lpc2148_6.png)

###### Attention!
Все действия, указанные выше, нужно делать без отключения аддона от Chip'plino. После стирания 0-ого сектора чип нужно будет 1 раз перезагрузить. Это можно сделать командами:

```bash
# Отключить питание МК
py.exe chipctrl.py -p COM5 -gp 4 0
# Включить питание МК
py.exe chipctrl.py -p COM5 -gp 4 1
```
После перезагрузки JTAG должен работать.
#### Links
* https://www.nxp.com/docs/en/user-guide/UM10139.pdf
* https://recon.cx/2017/brussels/resources/slides/RECON-BRX-2017-Breaking_CRP_on_NXP_LPC_Microcontrollers_slides.pdf